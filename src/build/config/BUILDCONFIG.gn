# Copyright (c) 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# =============================================================================
# WHAT IS THIS FILE?
# =============================================================================
#
# This is the master GN build configuration. This file is loaded after the
# build args (args.gn) for the build directory and after the toplevel ".gn"
# file (which points to this file as the build configuration).
#
# This file will be executed and the resulting context will be used to execute
# every other file in the build. So variables declared here (that don't start
# with an underscore) will be implicitly global.

# =============================================================================
# PLATFORM SELECTION
# =============================================================================
#
# There are two main things to set: "os" and "cpu". The "toolchain" is the name
# of the GN thing that encodes combinations of these things.
#
# Users typically only set the variables "target_os" and "target_cpu" in "gn
# args", the rest are set up by our build and internal to GN.
#
# There are three different types of each of these things: The "host"
# represents the computer doing the compile and never changes. The "target"
# represents the main thing we're trying to build. The "current" represents
# which configuration is currently being defined, which can be either the
# host, the target, or something completely different (like nacl). GN will
# run the same build file multiple times for the different required
# configuration in the same build.
#
# This gives the following variables:
#  - host_os, host_cpu, host_toolchain
#  - target_os, target_cpu, default_toolchain
#  - current_os, current_cpu, current_toolchain.
#
# Note the default_toolchain isn't symmetrical (you would expect
# target_toolchain). This is because the "default" toolchain is a GN built-in
# concept, and "target" is something our build sets up that's symmetrical with
# its GYP counterpart. Potentially the built-in default_toolchain variable
# could be renamed in the future.
#
# When writing build files, to do something only for the host:
#   if (current_toolchain == host_toolchain) { ...

if (target_os == "") {
  target_os = host_os
}

if (target_cpu == "") {
  if (target_os == "android") {
    # If we're building for Android, we should assume that we want to
    # build for ARM by default, not the host_cpu (which is likely x64).
    # This allows us to not have to specify both target_os and target_cpu
    # on the command line.
    target_cpu = "arm"
  } else {
    target_cpu = host_cpu
  }
}

if (current_cpu == "") {
  current_cpu = target_cpu
}
if (current_os == "") {
  current_os = target_os
}


# =============================================================================
# BUILD FLAGS
# =============================================================================
#
# This block lists input arguments to the build, along with their default
# values.
#
# If a value is specified on the command line, it will overwrite the defaults
# given in a declare_args block, otherwise the default will be used.
#
# YOU SHOULD ALMOST NEVER NEED TO ADD FLAGS TO THIS FILE. GN allows any file in
# the build to declare build flags. If you need a flag for a single component,
# you can just declare it in the corresponding BUILD.gn file.
#
# - If your feature is a single target, say //components/foo, you can put
#   a declare_args() block in //components/foo/BUILD.gn and use it there.
#   Nobody else in the build needs to see the flag.
#
# - Defines based on build variables should be implemented via the generated
#   build flag header system. See //build/buildflag_header.gni. You can put
#   the buildflag_header target in the same file as the build flag itself. You
#   should almost never set "defines" directly.
#
# - If your flag toggles a target on and off or toggles between different
#   versions of similar things, write a "group" target that forwards to the
#   right target (or no target) depending on the value of the build flag. This
#   group can be in the same BUILD.gn file as the build flag, and targets can
#   depend unconditionally on the group rather than duplicating flag checks
#   across many targets.
#
# - If a semi-random set of build files REALLY needs to know about a define and
#   the above pattern for isolating the build logic in a forwarding group
#   doesn't work, you can put the argument in a .gni file. This should be put
#   in the lowest level of the build that knows about this feature (which should
#   almost always be outside of the //build directory!).
#
# Other flag advice:
#
# - Use boolean values when possible. If you need a default value that expands
#   to some complex thing in the default case (like the location of the
#   compiler which would be computed by a script), use a default value of -1 or
#   the empty string. Outside of the declare_args block, conditionally expand
#   the default value as necessary.
#
# - Use a name like "use_foo" or "is_foo" (whatever is more appropriate for
#   your feature) rather than just "foo".
#
# - Write good comments directly above the declaration with no blank line.
#   These comments will appear as documentation in "gn args --list".
#
# - Don't call exec_script inside declare_args. This will execute the script
#   even if the value is overridden, which is wasteful. See first bullet.

declare_args() {
  # Set to enable the official build level of optimization. This has nothing
  # to do with branding, but enables an additional level of optimization above
  # release (!is_debug). This might be better expressed as a tri-state
  # (debug, release, official) but for historical reasons there are two
  # separate flags.
  is_official_build = false

  # Set to true when compiling with the Clang compiler.
  is_clang = current_os != "linux" ||
             (current_cpu != "s390x" && current_cpu != "s390" &&
              current_cpu != "ppc64" && current_cpu != "ppc" &&
              current_cpu != "mips" && current_cpu != "mips64" &&
              current_cpu != "riscv64")

  # Allows the path to a custom target toolchain to be injected as a single
  # argument, and set as the default toolchain.
  custom_toolchain = ""

  # This should not normally be set as a build argument.  It's here so that
  # every toolchain can pass through the "global" value via toolchain_args().
  host_toolchain = ""

  # DON'T ADD MORE FLAGS HERE. Read the comment above.
}

declare_args() {
  # Debug build. Enabling official builds automatically sets is_debug to false.
  is_debug = !is_official_build
}

declare_args() {
  # Component build. Setting to true compiles targets declared as "components"
  # as shared libraries loaded dynamically. This speeds up development time.
  # When false, components will be linked statically.
  #
  # For more information see
  # https://chromium.googlesource.com/chromium/src/+/master/docs/component_build.md
  is_component_build = is_debug && current_os != "ios"
}

assert(!(is_debug && is_official_build), "Can't do official debug builds")


# ==============================================================================
# TOOLCHAIN SETUP
# ==============================================================================
#
# Here we set the default toolchain, as well as the variable host_toolchain
# which will identify the toolchain corresponding to the local system when
# doing cross-compiles. When not cross-compiling, this will be the same as the
# default toolchain.
#
# We do this before anything else to make sure we complain about any
# unsupported os/cpu combinations as early as possible.
if (host_toolchain == "") {
  # This should only happen in the top-level context.
  # In a specific toolchain context, the toolchain_args()
  # block should have propagated a value down.
  # TODO(dpranke): Add some sort of assert here that verifies that
  # no toolchain omitted host_toolchain from its toolchain_args().

  if (host_os == "linux") {
    if (target_os != "linux") {
      host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
    } else if (is_clang) {
      host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
    } else {
      host_toolchain = "//build/toolchain/linux:$host_cpu"
    }
  } else if (host_os == "mac") {
    host_toolchain = "//build/toolchain/mac:clang_$host_cpu"
  } else if (host_os == "win") {
    # On Windows always use the target CPU for host builds for x86/x64. On the
    # configurations we support this will always work and it saves build steps.
    # Windows ARM64 targets require an x64 host for cross build.
    if (target_cpu == "x86" || target_cpu == "x64") {
      if (is_clang) {
        host_toolchain = "//build/toolchain/win:win_clang_$target_cpu"
      } else {
        host_toolchain = "//build/toolchain/win:$target_cpu"
      }
    } else if (is_clang) {
      host_toolchain = "//build/toolchain/win:win_clang_$host_cpu"
    } else {
      host_toolchain = "//build/toolchain/win:$host_cpu"
    }
  } else if (host_os == "aix") {
    host_toolchain = "//build/toolchain/aix:$host_cpu"
  } else {
    assert(false, "Unsupported host_os: $host_os")
  }
}
print("hello, world")
_default_toolchain = ""